pause函数
调用该函数可以造成进程主动挂起，等待信号唤醒。调用该系统调用的进程将处于阻塞状态(主动放弃cpu) 直到有信号递达将其唤醒。
int pause(void);	返回值：-1 并设置errno为EINTR
返回值：
① 如果信号的默认处理动作是终止进程，则进程终止，pause函数么有机会返回。
② 如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回。
③ 如果信号的处理动作是捕捉，则【调用完信号处理函数之后，pause返回-1】
errno设置为EINTR，表示“被信号中断”。想想我们还有哪个函数只有出错返回值。
④ pause收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒。

练习：使用pause和alarm来实现sleep函数。	【mysleep.c】
注意，unslept = alarm(0)的用法。
例如：睡觉，alarm(10)闹铃。	
正常： 10后闹铃将我唤醒，这时额外设置alarm(0)取消闹铃，不会出错。
		异常： 5分钟，被其他事物吵醒，alarm(0)取消闹铃防止打扰。
